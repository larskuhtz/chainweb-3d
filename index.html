<head>
  <style> 
    body { margin: 0; } 
  </style>
  <script src="http://unpkg.com/3d-force-graph"></script>
</head>

<body>
  <div id="3d-graph"></div>

  <script>
    /* ---------------------------------------------------------------------- */
    /* Config */

    const headerStreamHost = "us3.tn1.chainweb.com";
    const apiHost = "us1.tn1.chainweb.com";

    /* ---------------------------------------------------------------------- */
    /* Chainweb API */

    const headerStreamUrl = `https://${headerStreamHost}/chainweb/0.0/development/header/updates`;

    function getHeaderRequest (cid, hash) {
      const url = `https://${apiHost}/chainweb/0.0/development/chain/${cid}/header/${hash}`;
      return new Request(url, { headers: new Headers({ accept: "application/json;blockheader-encoding=object" })});
    }

    function getPayloadRequest (cid, hash) {
      const url = `https://${apiHost}/chainweb/0.0/development/chain/${cid}/payload/${hash}`;
      return new Request(url);
    }

    /* Fetch header */
    function fetchHeader (cid, hash, f) {
      fetch(getHeaderRequest(cid, hash))
        .then(r => r.json())
        .then(hdr =>
          fetch(getPayloadRequest(cid, hdr.payloadHash))
            .then(r => r.json())
            .then(p => f({ header: hdr, txCount: p.transactions.length }))
        );
    }

    /* ---------------------------------------------------------------------- */
    /* Graph */

    /* If a node is in this map than it also is in the graph. The values are links to 
     * the node data.
     */
    hashes = {};

    const elem = document.getElementById("3d-graph");
    const Graph = ForceGraph3D()(elem)
        .enableNodeDrag(false)
        .nodeId(x => x.id)

        // Arrow heads
        .linkDirectionalArrowLength(3.5)
        .linkDirectionalArrowRelPos(1)

        // DAG mode
        .dagMode('lr')
        .dagLevelDistance(100)

        // Color by ChainId
        .nodeAutoColorBy(d => d.data.header.chainId)
        .linkAutoColorBy(d => hashes[d.source].header.chainId)
        .linkOpacity(0.5)
        .linkWidth(0.5)

        // Node size by tx count
        .nodeVal(d => hashes[d.id].txCount * 0.02 + 1)
        .linkDirectionalParticles(d => {
          const s = d.source.id ? d.source.id : d.source;
          const t = d.target.id ? d.target.id : d.target;
          if (hashes[s].header.chainId == hashes[t].header.chainId) {
            return Math.max(0, hashes[s].txCount);
          } else {
            return 0;
          }
        })
        .linkDirectionalParticleSpeed(d => {
          const s = d.source.id ? d.source.id : d.source;
          const t = d.target.id ? d.target.id : d.target;
          if (hashes[s].header.chainId == hashes[t].header.chainId) {
            return Math.max(0, hashes[s].txCount * 0.005);
          } else {
            return 0;
          }
        })
        .linkDirectionalParticleWidth(2.5)


        // Label
        .nodeLabel(x => {
          const d = hashes[x.id];
          return `<div>
            <div>hash: ${d.header.hash}</div>
            <div>chainId: ${d.header.chainId}</div>
            <div>height: ${d.header.height}</div>
            <div>txCount: ${d.txCount}</div>
          </div>`
        })

        // .onNodeClick(x => showDetails(x.data))
        // .onNodeClick(d => Graph.emitParticle(d))

        .onNodeClick(node => {
          // Aim at node from outside it
          const distance = 40;
          const distRatio = 1 + distance/Math.hypot(node.x, node.y, node.z);
          Graph.cameraPosition(
            { x: node.x * distRatio, y: node.y * distRatio, z: node.z * distRatio }, // new position
            node, // lookAt ({ x, y, z })
            3000  // ms transition duration
          );
        })


        // .onNodeHover(node => elem.style.cursor = node ? 'pointer' : null)
        // .graphData(initData);

    var maxHeight = 0

    /* assumes that the node for the given data, if it exists, doesn't have any links */
    function updateGraph (data, b) {

      /* collect node data */
      const hdr = data.header;
      const hash = hdr.hash;
      const parents = { ...data.header.adjacents };
      parents[hdr.chainId.toString()] = hdr['parent'];

      /* Create new nodes and links */
      var newNodes = [];
      var newLinks = [];

      if (! (hash in hashes)) {
        newNodes.push({id : hash, data: data});
        hashes[hash] = data;
      } else {
        /* FIXME why isn't this updating the data in the graph node */
        hashes[hash].header = data.header;
        hashes[hash].txCount = data.txCount;
      }

      Object.entries(parents).forEach(([cidText, phash]) => {
        const pcid = parseInt(cidText, 10);
        newLinks.push({source: phash, target: hash});
        if (! (phash in hashes)) {
          const pheight = hdr.height - 1;
          const phdr = {chainId: pcid, hash: phash, height: pheight };
          const pdata = {header: phdr, txCount: -1};
          const pnode = {id: phash, data: pdata};
          newNodes.push(pnode);
          hashes[phash] = pdata;
          updateNode(pdata, b);
        }
      });

      /* Check if maxHeight changed */
      const maxHeight_ = Math.max(maxHeight, hdr.height);
      const updatedHeight = maxHeight !== maxHeight_;
      maxHeight = maxHeight_;
      const lower = typeof b === 'number' ? b : b(maxHeight);

      /* update the graph */
      let { nodes, links } = Graph.graphData();
      if (updatedHeight) {
        links = links.filter(l => hashes[l.source].data.header.height >= lower);
        nodes = nodes.filter(n => hashes[n.id].data.header.height >= lower);
      }
      Graph.graphData({
          nodes: [...nodes, ...newNodes ],
          links: [...links, ...newLinks ]
      });
      /* FIXME: is this asynchronous? I hope not. Otherwise we'd have to be more careful
       * in particular when updating hashes
       */
    }

    function updateNode (data, b) {
      const lower = typeof b === 'number' ? b : b(maxHeight);
      if (lower < data.header.height) {
        fetchHeader(data.header.chainId, data.header.hash, function(newData) {
          updateGraph(newData, lower);
        });
      }
    }

    /* ---------------------------------------------------------------------- */
    /* Main */

    /* Event Source */
    const headerStream = new EventSource(headerStreamUrl);
    headerStream.addEventListener("BlockHeader", function(event) {
        var jdata = JSON.parse(event.data);
        updateGraph(jdata, h => Math.max(0, h - 100));
    });
  </script>
</body>

